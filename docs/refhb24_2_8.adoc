=== Wertebereiche und Konstanten
Mit der Vorstellung eines Wertebereichs sind verschiedene Aspekte verbunden. Primär muss ein Datentyp festgelegt werden. Die INTERLIS-Datentypen sind unabhängig von der Implementation. Es wird deshalb z.B. nicht von Integer oder Real, sondern einfach von numerischen Datentypen gesprochen (vgl. Kapitel 2.8.5 Numerische Datentypen).

Ist der Datentyp festgelegt, sind – je nach Datentyp – noch weitere Präzisierungen nötig oder möglich. Ist eine Wertebereich-Definition noch unvollständig (fehlt z.B. bei einem numerischen Wertebereich noch die konkrete Bereichsdefinition), muss sie als abstrakt deklariert werden (Schlüsselwort `ABSTRACT`, Regel Properties). Um insbesondere den Übergang von LV03- auf LV95-Koordinaten zu erleichtern, kann der Wertebereich von Koordinaten als generisch (Schlüsselwort `GENERIC`, Regel Properties) definiert werden. Die verwendenden Wertebereiche (insbesondere Linien), Attribute, Klassen und Themen müssen deswegen nicht abstrakt definiert werden, obwohl der Koordinaten-Wertebereich erst in spezifischen Modellen oder sogar erst in den Transferdaten festgelegt wird (vgl. Kapitel 2.8.8 Koordinaten).

Wertebereiche können – wie andere Konstrukte – auch geerbt und dann erweitert werden, sofern sie nicht als `FINAL` definiert wurden. Wichtig ist dabei der Grundsatz, dass eine erweiterte Definition immer mit der Basis-Definition kompatibel sein muss. Bei Wertebereichen sind Erweiterungen (Schlüsselwort `EXTENDS`) somit eigentlich Präzisierungen bzw. Einschränkungen. Das Schlüsselwort `EXTENDED` (Regel Property) ist nicht zulässig. Im Interesse der Lesbarkeit wird empfohlen, Definitionsteile von Basis-Wertebereichen (z.B. die Masseinheit) in der Erweiterung auch dann zu wiederholen, wenn sie unverändert sind.

.Beispiel:
====
----
DOMAIN
  Wert (ABSTRACT) = NUMERIC .. NUMERIC;    !! abstrakter Wertebereich
  GenWert EXTENDS Wert = 10.0 .. 100.0;    !! konkrete Erweiterung
  SpezWert EXTENDS GenWert = 20.0 .. 90.0; !! in Ordnung
  SpezWert EXTENDS GenWert = 0.0 .. 110.0; !! falsch, da unverträglich
----
====

Eine wichtige Frage bei der Definition von Wertebereichen ist, ob der Wert "Undefiniert" auch zum Wertebereich gehört oder nicht. Ohne weitere Angabe gehört er dazu. Es kann aber verlangt werden, dass er nicht dazu gehört, d.h. dass ein Attribut mit diesem Wertebereich immer definiert sein muss (Schlüsselwort `MANDATORY`). `MANDATORY` allein ist nur bei Erweiterungen zulässig.

Bei der Definition eines Attributs einer Klasse oder Struktur (und nur dort) darf auch dann `MANDATORY` stehen, wenn der Wertebereich als `FINAL` deklariert wurde und somit eigentlich nicht weiter eingeschränkt werden dürfte.

Mit dem Schlüsselwort `CONSTRAINTS` kann die Wertebereichsdefinition um eine oder mehrere Einschränkungen ergänzt werden, um z.B. bei einem Textwertebereich nur bestimmte Zeichenfolgenmuster zuzulassen. Werden mehrere Einschränkungen gemacht, gelten alle. Jede Einschränkung hat innerhalb der Wertebereichsdefinition einen eindeutigen Namen.

++++
<a href="#2_8_C1">&#x203B</a>
++++
[#2_8_C1]
.Syntaxregeln:
----
DomainDef = 'DOMAIN'
               { Domain-Name Properties<ABSTRACT,GENERIC,FINAL>
                   [ 'EXTENDS' DomainRef ] '='
               ( 'MANDATORY' [ Type ] | Type ) [ 'CONSTRAINTS'
                 Constraints-Name ':' Logical-Expression
                 { ',' Constraints-Name ':' Logical-Expression } ] ';' }.

Type = ( BaseType | LineType ).

DomainRef = [ Model-Name '.' [ Topic-Name '.' ] ] Domain-Name.

BaseType = ( TextType
           | EnumerationType
           | EnumTreeValueType
           | AlignmentType
           | BooleanType
           | NumericType
           | FormattedType
           | DateTimeType
           | CoordinateType
           | OIDType
           | BlackboxType
           | ClassType
           | AttributePathType ).
----

In Vergleichsoperationen (vgl. Kapitel 2.13 Ausdrücke) können Attributwerte auch mit Konstanten verglichen werden. Diese sind wie folgt definiert:

----
Constant = ( 'UNDEFINED'
           | NumericConst
           | TextConst
           | FormattedConst
           | EnumerationConst
           | ClassConst
           | AttributePathConst ).
----

Die typenspezifischen Konstanten sind bei den einzelnen Datentypen definiert.

==== Zeichenketten
Eine Zeichenkette ist eine Folge von Zeichen mit einer maximalen Länge. Der Zeichenvorrat muss klar definiert sein (vgl. Anhang D Zeichentabelle).

Im Datentyp `MTEXT` sind die Zeichen «Carriage Return» (Wagenrücklauf) (#xD), «Line Feed» (Zeilenvorschub) (#xA) und «Tabulatorzeichen» (#x9), im Gegensatz zum Wertebereich des Datentyps `TEXT`, enthalten.

Beim Datentyp Zeichenkette (`TEXT`) ist primär die Länge der Zeichenkette von Interesse. Je nach der Form der Definition wird sie explizit oder implizit angegeben. Bei der expliziten Form (`TEXT * ...`) wird die maximale Länge in Anzahl Zeichen festgelegt (grösser Null). Werden nur die Schlüsselwörter `TEXT` oder `MTEXT` angegeben, ist die Anzahl Zeichen unbeschränkt. Im Rahmen einer Erweiterung kann die Länge verkürzt werden (eine Verlängerung würde zu einem Wertebereich führen, der mit dem Basis-Wertebereich nicht mehr verträglich ist).

Die INTERLIS-Zeichenkettenlänge bezeichnet die Zahl der Zeichen, wie sie von Benutzern wahrgenommen wird, nicht aber die Zahl der Speicherstellen, die ein System maximal zur Repräsentation einer Zeichenkette benötigt. Zeichenketten der Länge null gelten als undefiniert.

Bemerkung: Im Zusammenhang mit INTERLIS ist die Länge einer Zeichenkette als Anzahl jener Zeichen definiert, welche gemäss Unicode-Standard die kanonische Kombinationsklasse Nr. 0 besitzen, nachdem die Zeichenkette in die kanonisch dekomponierte Form von Unicode gebracht wurde (siehe https://www.unicode.org/unicode/reports/tr15/). So besitzt etwa eine Zeichenkette, die aus der Kette <LATIN CAPITAL LETTER C WITH CIRCUMFLEX><COMBINING CEDILLA> besteht, ebenso die Länge 1 wie die äquivalente Zeichenkette <LATIN CAPITAL LETTER C>< COMBINING CIRCUMFLEX ACCENT><COMBINING CEDILLA>. Gemäss der obigen Definition besitzen Ligaturen für «fl» oder «ffi» die Länge 1. Es wird aber davon abgeraten, solche Darstellungsformen überhaupt für Zeichenkettenattribute zu verwenden.

Der Namen-Zeichenkettentyp (Schlüsselwort `NAME`) definiert einen Wertebereich, der genau demjenigen der INTERLIS-Namen entspricht (vgl. Kapitel 2.2.2 Namen). Er wird in der vordefinierten Klasse `METAOBJECT` (siehe vordefiniertes Basismodell INTERLIS) und damit vor allem in den Klassen für Referenzsysteme sowie Signaturen eingesetzt (vgl. Kapitel 2.10.3 Referenzsysteme und Kapitel 2.16 Darstellungsbeschreibungen), weil dort Datenattribute mit Beschreibungselementen von Modellen übereinstimmen müssen.

Als weiterer Zeichenkettentyp wird der URI (Uniform Resource Identifier) geführt, z.B. http-, ftp- oder mailto-Adressen (s. Abschnitt 1.2 im Internet-Standard IETF RFC 2396 in https://www.w3.org). Die Länge eines URI ist in INTERLIS auf 1023 Zeichen beschränkt. Er entspricht damit folgender Definition:

----
DOMAIN
  URI (FINAL) = TEXT*1023;  !! ACHTUNG: gemäss IETF RFC 2396
  NAME (FINAL) = TEXT*255;  !! ACHTUNG: gemäss Kapitel 2.2.2 Namen
----

++++
<a href="#2_8_C2">&#x203B</a>
++++
[#2_8_C2]
.Syntaxregeln:
----
TextType = ( 'MTEXT' [ '*' MaxLength-PosNumber ]
           | 'TEXT' [ '*' MaxLength-PosNumber ]
           | 'NAME'
           | 'URI' ).

TextConst = String.
----

==== Aufzählungen
Mit einer Aufzählung werden die für diesen Typ zulässigen Werte festgelegt. Die Aufzählung ist jedoch nicht einfach linear, sondern im Sinne eines Baumes strukturiert. Die Blätter des Baumes (nicht aber die Knoten) bilden die Menge der zulässigen Werte.

.Beispiel:
====
----
DOMAIN
  Farben = (rot (dunkelrot, orange, karmin),
            gelb,
            gruen (hellgruen, dunkelgruen));
----
ergibt die folgenden - mittels Konstanten beschriebenen - zulässigen Werte:
----
#rot.dunkelrot #rot.orange #rot.karmin #gelb #gruen.hellgruen #gruen.dunkelgruen
----
.Beispiel einer Aufzählung
image::{includedir}/img/refhb24_fig8.png[]
====

Eine Schachtelung wird in runden Klammern angegeben. Die Elementnamen jeder Schachtelung müssen eindeutig sein. Die Schachtelungstiefe ist frei wählbar.

Ist eine Aufzählung geordnet (Schlüsselwort `ORDERED`), ist eine Reihenfolge der Elemente definiert. Ist die Aufzählung zirkulär (Schlüsselwort `CIRCULAR`), ist die Reihenfolge der Elemente definiert, wie wenn die Aufzählung geordnet wäre. Zudem wird ausgesagt, dass nach dem letzten Element wieder das erste folgt.

Nebst der eigentlichen Aufzählungsdefinition ist es auch möglich, einen Wertebereich zu definieren, der als zulässige Werte alle Blätter und Knoten einer Aufzählungsdefinition umfasst (`ALL`). Einem solchen Attribut kann darum auch der Wert eines Attributs, der zu Grunde liegenden Aufzählungsdefinition zugewiesen werden.

.Beispiele:
====
----
DOMAIN
  Lage = (unten, mitte, oben) ORDERED;
  Wochentage = (Werktage (Montag, Dienstag, Mittwoch,
                          Donnerstag, Freitag, Samstag),
                Sonntag) CIRCULAR;
  WochentagsWerte = ALL OF Wochentage;
----
====

++++
<a href="#2_8_C3">&#x203B</a>
++++
[#2_8_C3]
.Syntaxregeln:
----
EnumerationType = Enumeration [ 'ORDERED' | 'CIRCULAR' ].

EnumTreeValueType = 'ALL' 'OF' Enumeration-DomainRef.

Enumeration = '(' EnumElement { ',' EnumElement } [ ':' 'FINAL' ]
               | 'FINAL' ')'.

EnumElement = EnumElement-Name { '.' EnumElement-Name } [Sub-Enumeration].

EnumerationConst = '#' ( EnumElement-Name { '.' EnumElement-Name }
                                          [ '.' 'OTHERS' ]
                       | 'OTHERS' ).
----

Im Rahmen von Neudefinitionen von Aufzählungen (Primärdefinition, zusätzliche Elemente einer Erweiterung) darf das EnumElement nur aus einem Namen bestehen. Mehrere Namen sind nur zulässig, um für eine Erweiterung ein bisheriges Aufzählungselement zu identifizieren.

Aufzählungen können einerseits erweitert werden, indem für Blätter (also Aufzählungselemente, die keine Unter-Aufzählung aufweisen) der bisherigen Aufzählung Unter-Aufzählungen definiert werden. In der erweiterten Definition werden aus bisherigen Blättern neu Knoten, für die keine Werte definiert werden dürfen.

Andererseits kann jede einzelne Teilaufzählung in Erweiterungen durch weitere Elemente (Knoten oder Blätter) ergänzt werden. Die Basisaufzählungen umfassen dadurch nebst den genannten Elementen immer auch noch potenziell weitere Elemente, die erst in Erweiterungen definiert werden. Solche potenziellen Werte können auf der Basisstufe in Ausdrücken, Funktionsargumenten und Signaturzuweisungen (vgl. Kapitel 2.13 Ausdrücke, Kapitel 2.14 Funktionen und Kapitel 2.16 Darstellungsbeschreibungen) mit dem Wert `OTHERS` angesprochen werden. `OTHERS` ist jedoch kein zulässiger Wert im Rahmen der Klasse, zu der das Objekt gehört. Die Möglichkeit, in Erweiterungen zusätzliche Aufzählelemente anfügen zu können, kann unterbunden werden, indem die Teilaufzählung als abschliessend erklärt wird (`FINAL`). Dies erfolgt entweder nach dem letzten aufgeführten Element oder im Rahmen einer Erweiterung auch ohne dass neue Elemente angefügt werden.

Zirkuläre Aufzählungen (Schlüsselwort CIRCULAR) können nicht erweitert werden.

.Beispiel:
====
----
DOMAIN
  Farbe = (rot,
           gelb,
           gruen);
  FarbePlus EXTENDS Farbe = (rot (dunkelrot, orange, karmin),
                             gruen (hellgruen, dunkelgruen: FINAL),
                             blau);
  FarbePlusPlus EXTENDS FarbePlus = (rot (FINAL),
                                     blau (hellblau, dunkelblau));
----
ergibt für FarbePlus die folgenden - mittels Konstanten beschriebenen - zulässigen Werte:
----
#rot.dunkelrot #rot.orange #rot.karmin #gelb #gruen.hellgruen #gruen.dunkelgruen #blau
----
und für FarbePlusPlus:
----
#blau.hellblau #blau.dunkelblau statt #blau
----
Durch die Angabe von `FINAL` bei den Grünstufen von FarbePlus ist es in FarbePlusPlus nicht zulässig weitere Grünstufen zu definieren. Mit der Angabe von `FINAL` für die Unterteilung von Rot in FarbePlusPlus wird verhindert, dass in möglichen Erweiterungen von FarbePlusPlus noch weitere Rotvarianten angefügt werden können.
====

==== Textausrichtungen
Für die Aufbereitung von Plänen und Karten müssen die Positionen von Texten festgehalten werden. Dabei muss festgelegt werden, welcher Stelle des Textes die Position entspricht. Mit dem horizontalen Alignment wird festgelegt, ob die Position auf dem linken oder rechten Rand des Textes oder in der Textmitte liegt. Das vertikale Alignment legt die Position in Richtung der Texthöhe fest.

Der Abstand Cap-Base entspricht der Höhe der Grossbuchstaben. Unterlängen befinden sich im Bereich von Base-Bottom.

.Textausrichtung horizontal (`HALIGNMENT`) und vertikal (`VALIGNMENT`).
image::{includedir}/img/refhb24_fig9.png[]

Horizontales und vertikales Alignment können als folgende vordefinierte Aufzählung verstanden werden:

----
DOMAIN
  HALIGNMENT (FINAL) = (Left, Center, Right) ORDERED;
  VALIGNMENT (FINAL) = (Top, Cap, Half, Base, Bottom) ORDERED;
----

++++
<a href="#2_8_C4">&#x203B</a>
++++
[#2_8_C4]
.Syntaxregel:
----
AlignmentType = ( 'HALIGNMENT' | 'VALIGNMENT' ).
----

==== Boolean
Der Typ Boolean weist die Werte false und true auf. Er kann als folgende vordefinierte Aufzählung verstanden werden:

----
DOMAIN
  BOOLEAN (FINAL) = (false, true) ORDERED;
----

++++
<a href="#2_8_C5">&#x203B</a>
++++
[#2_8_C5]
.Syntaxregel:
----
BooleanType = 'BOOLEAN'.
----

==== Numerische Datentypen
Die wichtigste Angabe bei numerischen Datentypen ist der Minimal- und der Maximal-Wert inklusive Stellenzahl (Nachkommastellen) sowie der Skalierungsfaktor. Zusätzlich kann angegeben werden, dass der Typ zirkulär ist (Schlüsselwort `CIRCULAR`), d.h. dass der in der letzten signifikanten Stelle um 1 erhöhte Maximalwert und der Minimalwert sachlich die gleiche Bedeutung haben (z.B. bei Winkeln 0 .. 359 Grad). Ist das Attribut als eine kontinuierliche Unterteilung des Vorgängerattributs definiert (vgl. Kapitel 2.6.1 Allgemeine Aussagen zu Attributen), muss der Typ als zirkulär definiert sein. Fehlt die Angabe des Minimal- und Maximal-Wertes (Schlüsselwort `NUMERIC`), gilt der Wertebereich als abstrakt.

----
DOMAIN
  Winkel1 = 0.00 .. 359.99 CIRCULAR [degree]; !! richtig
  Winkel2 = 0.00 .. 360.00 CIRCULAR [degree]; !! syntaktisch zwar richtig,
                                              !! sachlich aber falsch, da damit
                                              !! 360.01 dem Minimalwert 0.00
                                              !! entspricht
----

Die Stellenzahl muss beim Minimal- und beim Maximal-Wert übereinstimmen. Mit Hilfe der Skalierung können Float-Zahlen beschrieben werden, aber dann sind sowohl der Minimal- als auch der Maximal-Wert in Mantissendarstellung anzugeben, d.h. beginnend mit Null (0) und gefolgt vom Dezimalpunkt (.) muss die erste Ziffer nach dem Dezimalpunkt von Null (0) verschieden sein. Die Skalierung des Minimalwertes muss kleiner sein als die Skalierung des Maximalwertes. Die Schreibweise von Minimal- und Maximalwert bedeutet aber keineswegs eine Anweisung, wie die Werte transferiert werden sollen (ist ein Wertebereich mit 000 .. 999 definiert, bedeutet das nicht, dass der Wert 7 als 007 transferiert wird). Eine Ausnahme von dieser Regel bilden die Float-Zahlen. Diese sind in Mantissendarstellung und mit Skalierung zu transferieren.

Bei Erweiterungen dürfen die Maximal- bzw. Minimalwerte nur eingeschränkt werden. Der numerische Bereich wird damit also kleiner. Man beachte dabei folgende Situation:

----
DOMAIN
  Normal = 0.00 .. 7.99;
  Genau EXTENDS Normal = 0.0000 .. 7.9949;    !! richtig, da auch
                                              !! Normal darstellbar
  Genau EXTENDS Normal = 0.0000 .. 7.9999;    !! falsch, da gerundet
                                              !! ausserhalb Normal
----

Um die Bedeutung des Wertes genauer zu erklären kann eine Masseinheit angegeben werden (vgl. Kapitel 2.9 Einheiten). Abstrakte Masseinheiten sind nur zulässig, solange der Wertebereich selbst noch undefiniert ist (Schlüsselwort `NUMERIC`).

Für Erweiterungen gelten folgende Regeln:

* Weist ein konkreter Basis-Wertebereich keine Masseinheit auf, darf auch in Erweiterungen des Basis-Wertebereichs keine angegeben werden.

* Verwendet der Basis-Wertebereich eine abstrakte Masseinheit, dürfen in Erweiterungen des Basis-Wertebereichs nur Masseinheiten verwendet werden, die Erweiterungen der Masseinheit sind.

* Verwendet der Basis-Wertebereich eine konkrete Masseinheit, kann sie in Erweiterungen nicht übersteuert werden.

.Beispiele:
====
----
UNIT
  foot [ft] = 0.3048 [m];

DOMAIN
  Distanz (ABSTRACT) = NUMERIC [Length];
  MeterDist (ABSTRACT) EXTENDS Distanz = NUMERIC [m];
  FussDist (ABSTRACT) EXTENDS Distanz = NUMERIC [ft];
  KurzeMeter EXTENDS MeterDist = 0.00 .. 100.00 [m];
  KurzeFuesse EXTENDS FussDist = 0.00 .. 100.00 [ft];
  KurzeFuesse2 (ABSTRACT) EXTENDS KurzeMeter = NUMERIC [ft]; !! falsch: m vs. ft
----
====

Einem numerischen Wertebereich kann auch ein Skalarsystem zugeordnet werden (vgl. Kapitel 2.10.3 Referenzsysteme). Damit beziehen sich die Werte auf den durch das Skalarsystem bestimmten Nullpunkt. Es sind also absolute Werte in diesem Skalarsystem. Ist in der Klasse des Skalarsystems die Einheit nicht `ANYUNIT`, muss beim numerischen Datentyp eine Einheit angegeben werden, die mit jener des Referenzsystems verträglich ist. Bezieht man sich auf ein Koordinatensystem, kann die Achse angegeben werden, auf die sich die Werte beziehen. Die Einheit muss mit jener der entsprechenden Achse verträglich sein. Fehlt diese Angabe, ist der Bezug nicht genauer definiert, sondern ergibt sich aus dem Fachgebiet (z.B. bezieht man sich bei einer Höhe auf ein Ellipsoid, meint man ellipsoidische Höhen). Bezieht man sich auf einen anderen Wertebereich, soll das gleiche Referenzsystem gelten wie bei diesem Wertebereich. In diesem Fall darf die Angabe der Achse nur fehlen, wenn es sich um einen numerischen Wertebereich handelt. Bei einem Koordinatenwertebereich ist die Achsenangabe obligatorisch. Die Angabe des Referenzsystems kann in Erweiterungen nicht mehr geändert werden.

Stellt der numerische Wert einen Winkel dar, kann sein Richtungssinn festgelegt werden. Im Falle von Richtungen kann angegeben werden, auf welches Koordinatensystem (definiert durch einen Koordinaten-Wertebereich) sich die Richtung bezieht. Damit ist bekannt, wie die Nullrichtung (Azimut) und der Drehsinn definiert sind (vgl. Kapitel 2.8.8 Koordinaten). Diese Angabe kann in Erweiterungen nicht mehr geändert werden.

Als numerische Konstanten sind nebst den Dezimalzahlen auch die Zahlen Pi (Schlüsselwort `PI`) und e – Basis des natürlichen Logarithmus – (Schlüsselwort `LNBASE`) definiert.

++++
<a href="#2_8_C6">&#x203B</a>
++++
[#2_8_C6]
.Syntaxregeln:
----
NumericType = ( Min-Dec '..' Max-Dec | 'NUMERIC' ) [ 'CIRCULAR' ]
              [ '[' UnitRef ']' ]
              [ 'CLOCKWISE' | 'COUNTERCLOCKWISE' | RefSys ].

RefSys = ( '{' RefSys-MetaObjectRef [ '[' Axis-PosNumber ']' ] '}'
         | '<' Coord-DomainRef [ '[' Axis-PosNumber ']' ] '>' ).

DecConst = ( Dec | 'PI' | 'LNBASE' ).

NumericConst = DecConst [ '[' UnitRef ']' ].
----

==== Formatierte Wertebereiche
Formatierte Wertebereiche basieren auf Strukturen und verwenden deren numerische oder formatierte Attribute in einem Format. Dieses Format dient einerseits dem Datenaustausch (vgl. 3.3.11.5 Codierung von formatierten Wertebereichen), andererseits der Definition von unterer und oberer Grenze des Wertebereichs.

++++
<a href="#2_8_C7">&#x203B</a>
++++
[#2_8_C7]
.Syntaxregeln:
----
FormattedType = ( 'FORMAT' ( 'BASED' 'ON' StructureRef FormatDef
                             [ Min-String '..' Max-String ]
                           | FormattedType-DomainRef
                             Min-String '..' Max-String
                           ) )
                | Min-String '..' Max-String.

FormatDef = '(' [ 'INHERITANCE' ]
                  [ NonNum-String ] { BaseAttrRef NonNum-String }
                                      BaseAttrRef [ NonNum-String ] ')'.

BaseAttrRef = ( NumericAttribute-Name [ '/' IntPos-PosNumber ]
              | StructureAttribute-Name '/' Formatted-DomainRef ).

FormattedConst = String.
----

Eine Basisdefinition eines formatierten Wertebereichs definiert primär die Struktur, auf welcher er aufbaut und das Format das zur Anwendung kommt. Zusätzlich können die untere und obere Grenze des Wertebereichs definiert werden. Sie dürfen die mit der Struktur definierten Grenzen nicht ausweiten.

Im Rahmen einer Erweiterung kann auf eine Erweiterung der ursprünglichen Struktur Bezug genommen, das Format ergänzt (der geerbte Teil muss am Anfang stehen und im Interesse von Klarheit mittels des Schlüsselwortes `INHERITANCE` erwähnt werden) und der Wertebereich eingeschränkt werden.

In der Formatdefinition können einerseits konstante Strings, die nicht mit einer Ziffer beginnen (am Anfang, am Ende und zwischen den einzelnen Attributreferenzen) und andererseits direkte oder indirekte Attributreferenzen (über Strukturattribute) enthalten sein. Die Attributreferenz muss entweder ein numerisches Attribut oder ein Strukturattribut bezeichnen. Im Falle eines numerischen Attributes können Vorkommastellen festgelegt werden. Als Folge ergeben sich nötigenfalls führende Nullen. Die Nachkommastellen ergeben sich aus dem numerischen Wertebereich. Bei Strukturattributen muss definiert werden, gemäss welchem formatierten Wertebereich es formatiert werden soll. Die Struktur muss mit der Basisstruktur des Wertebereichs übereinstimmen oder eine Erweiterung davon sein.

==== Datum und Zeit
Wo Datums- oder Zeitangaben nicht nur aus einem einzigen Wert (z.B. Jahr, Sekunde) bestehen, werden üblicherweise formatierte Wertebereiche verwendet.

++++
<a href="#2_8_C8">&#x203B</a>
++++
[#2_8_C8]
.Syntaxregel:
----
DateTimeType = ( 'DATE' | 'TIMEOFDAY' | 'DATETIME' ).
----

Die Wertebereiche für `DATE`, `TIMEOFDAY` bzw. `DATETIME` entsprechen den im Folgenden definierten `INTERLIS.XMLDate`, `INTERLIS.XMLTime` bzw. `INTERLIS.XMLDateTime`.

Im Interesse der Kompatibilität mit XML werden entsprechende Elemente durch INTERLIS vordefiniert:

----
UNIT
  Minute [min] = 60 [INTERLIS.s];
  Hour   [h]   = 60 [min];
  Day    [d]   = 24 [h];
  Month [M] EXTENDS INTERLIS.TIME;
  Year [Y] EXTENDS INTERLIS.TIME;

REFSYSTEM BASKET BaseTimeSystems ~ TIMESYSTEMS
  OBJECTS OF CALENDAR: GregorianCalendar
  OBJECTS OF TIMEOFDAYSYS: UTC;

STRUCTURE TimeOfDay (ABSTRACT) =
  Hours: 0 .. 23 CIRCULAR [h];
  CONTINUOUS SUBDIVISION Minutes: 0 .. 59 CIRCULAR [min];
  CONTINUOUS SUBDIVISION Seconds: 0.000 .. 59.999 CIRCULAR [INTERLIS.s];
END TimeOfDay;

STRUCTURE UTC EXTENDS TimeOfDay =
  Hours(EXTENDED): 0 .. 23 {UTC};
END UTC;

DOMAIN
  GregorianYear = 1582 .. 2999 [Y] {GregorianCalendar};

STRUCTURE GregorianDate =
  Year: GregorianYear;
  SUBDIVISION Month: 1 .. 12 [M];
  SUBDIVISION Day: 1 .. 31 [d];
END GregorianDate;

STRUCTURE GregorianDateTime EXTENDS GregorianDate =
  SUBDIVISION Hours: 0 .. 23 CIRCULAR [h] {UTC};
  CONTINUOUS SUBDIVISION Minutes: 0 .. 59 CIRCULAR [min];
  CONTINUOUS SUBDIVISION Seconds: 0.000 .. 59.999 CIRCULAR [INTERLIS.s];
END GregorianDate;

DOMAIN XMLDate = FORMAT BASED ON GregorianDate ( Year/4 "-" Month/2 "-" Day/2 );
DOMAIN XMLTime = FORMAT BASED ON UTC ( Hours/2 ":" Minutes/2 ":" Seconds/2 );
DOMAIN XMLDateTime EXTENDS XMLDate = FORMAT BASED ON GregorianDateTime
                           ( INHERITANCE "T" Hours/2 ":" Minutes/2 ":" Seconds/2 );
----

.Anwendungsbeispiel:
====
----
CLASS Projekt =
  Start: FORMAT INTERLIS.XMLDateTime "2000-01-01T00:00:00.000" ..
                                     "2005-12-31T23:59:59.999";
  Ende: FORMAT INTERLIS.XMLDateTime "2002-01-01T00:00:00.000" ..
                                    "2007-12-31T23:59:59.999";
END Projekt;
----
====

==== Koordinaten
Koordinaten können ein-, zwei- oder dreidimensional definiert werden und sind entsprechend eine Einzelzahl, ein Zahlenpaar oder ein Zahlentripel. Es ist zulässig, dass die zweite oder dritte Dimension erst in einer Erweiterung beigefügt wird. Für jede Dimension muss der numerische Wertebereich sowie allenfalls eine Masseinheit und ein Koordinatensystem (inkl. Achsnummern) angegeben werden. Es gelten die gleichen Regeln wie bei den numerischen Datentypen. Es können nur konkrete Masseinheiten angegeben werden. Wird kein Referenzsystem angegeben und sind die Masseinheiten entweder nicht oder als Längeneinheit definiert, darf ein Programmsystem, das das Modell implementiert, davon ausgehen, dass es sich um kartesische Koordinaten handelt.

Wird eine Rotationsangabe gemacht (Schlüsselwort `ROTATION`) kann im Rahmen von Richtungsdefinitionen (vgl. Kapitel 2.8.5 Numerische Datentypen) auf ein solches Koordinaten-Referenzsystem verwiesen werden. Die Rotationsdefinition legt fest, welche Achse des Koordinaten-Wertebereichs der Nullrichtung und welche der Richtung eines positiven, rechten Winkels entsprechen. Sie darf auch in einer konkreten Koordinatendefinition fehlen und dann allenfalls in einer Erweiterung beigefügt werden.

Die Angaben betreffend Achsbezug und Rotation können in Erweiterungen nicht geändert werden.

.Beispiel
====
----
DOMAIN
  CHKoord = COORD 480000.00 .. 850000.00 [m] {CHLV03[1]},
                   60000.00 .. 320000.00 [m] {CHLV03[2]},
                  ROTATION 2 -> 1 REFSYS "EPSG:21781";
----

Bei den zwei definierten Achsen wird nebst dem zulässigen Bereich angegeben, auf welche Einheiten und welches Referenzsystem samt Achsennummer sich die Koordinaten beziehen. Die eigentlichen Achsen sind beim Referenzsystem definiert. Die Rotationsdefinition legt fest, dass die Nullrichtung von der zweiten zur ersten Achse führt, beim Schweizerischen System, wo der erste Wert der Ostwert, der zweite der Nordwert ist, zeigt die Nullrichtung nach Norden und dreht im Uhrzeigersinn.
----
DOMAIN
  WGS84Koord = COORD –90.00000 ..  90.00000          [Units.Angle_Degree] {WGS84[1]},
                       0.00000 .. 359.99999 CIRCULAR [Units.Angle_Degree] {WGS84[2]},
                      -1000.00 .. 9000.00            [m] {WGS84Alt[1]};
----
Geografische Koordinaten sind typischerweise in Grad dargestellt und beziehen sich auf ein ellipsoidisches Koordinatensystem (z.B. CH1903). Die Höhe andererseits ist in Meter beschrieben. Sie bezieht sich auf ein spezielles Ellipsoid-Höhen-System mit einer Achse.
====

++++
<a href="#2_8_C9">&#x203B</a>
++++
[#2_8_C9]
.Syntaxregeln:
----
CoordinateType = ( 'COORD' | 'MULTICOORD' ) NumericType
                   [ ',' NumericType [ ',' NumericType ]
                       [ ',' RotationDef ] [ 'REFSYS' Name-String ] ].

RotationDef = 'ROTATION' NullAxis-PosNumber '->' PiHalfAxis-PosNumber.
----

Mit der optionalen Angabe REFSYS kann der EPSG-Codefootnote:[EPSG Geodetic Parameter Dataset. https://epsg.org] des Referenzsystems gemäss dem Muster EPSG:PosNumber festgelegt werden.

Mit dem Schlüsselwort `MULTICOORD` statt `COORD` wird als Wertebereich eine ungeordnete Menge von Koordinaten definiert. Im Unterschied zu einer Formulierung mit `LIST/BAG` haben die einzelnen Werte aber zwingend dasselbe Referenzsystem.

Sind die Definitionen unvollständig, muss der Wertebereich entweder als abstrakt (Property `ABSTRACT`) oder als generisch (Property `GENERIC`) deklariert werden.

Bei abstrakten Koordinatenbereichen kann selbst die Anzahl Dimensionen offen bleiben. Abstrakte Wertebereiche können nur in Attributen verwendet werden, die als abstrakt deklariert sind. Abstrakte Koordinatenbereiche können dann auf verschiedene Arten konkretisiert werden.

Bei generischen Koordinatenbereichen muss die Anzahl der Dimensionen festgelegt sein. Es ist aber zulässig, dass dabei nur die Angabe `NUMERIC` gemacht wird. Generische Wertebereiche können auch in Attributen verwendet werden, die nicht als abstrakt deklariert sind. Generische Koordinaten-Wertebereiche können gleich wie abstrakte konkretisiert werden. Dabei werden insbesondere die numerischen Wertebereiche der Achsen und das Referenzsystem (Concrete-DomainRef) festgelegt bzw. eingeschränkt.

----
DOMAIN
  Coord2 (GENERIC) = COORD NUMERIC, NUMERIC;

CLASS Punkt =
  Pos: Coord2;
END Punkt;
----

Das Thema (`TOPIC`), zu dem eine solche Definition gehört, muss aber als abstrakt deklariert werden, sofern keine Kontextdefinition wirkt.

Mit einer Kontextdefinition können für einen generischen Koordinaten-Wertebereich (Generic-CoordDef-DomainRef) konkrete Koordinaten-Wertebereiche definiert werden. Wurde für einen generischen Koordinaten-Wertebereich nicht nur ein einzelner, sondern eine Auswahl von möglichen konkreten Koordinaten-Wertebereichen festgelegt, wird beim Transfer des einzelnen Behälters, der für diesen Behälter geltende Wertebereich festgehalten (vgl. Kapitel 3.3.6 Codierung von Themen). Die Tatsache, dass die Festlegung aufgeschoben ist, muss beim Thema angemerkt werden (vgl. Kapitel 2.5.2 Themen). Der letztlich gültige konkrete Koordinaten-Wertebereich gilt bei allen Verwendungen des generischen Koordinaten-Wertebereichs und bei allen Verwendungen von Linien-Wertebereichen, die auf dem generischen Koordinaten-Wertebereich basieren.

++++
<a href="#2_8_C10">&#x203B</a>
++++
[#2_8_C10]
.Syntaxregel:
----
ContextDef = 'CONTEXT' { Context-Name '=' { GenericCoordDef-DomainRef '='
             Concrete-DomainRef { 'OR' Concrete-DomainRef } ';' } }.
----

Der Name des Kontexts ist ohne Bedeutung muss aber nach den allgemeinen Regeln eindeutig sein und dient z.B. für allfällige Fehlermeldungen. Ein Kontext wirkt in dem Modell wo er definiert wird und in allen Modellen, welche das definierende Modell direkt oder indirekt importieren.

----
CONTEXT default =
  MyModel.Coord2 = GeometryCHLV03.Coord2 OR GeometryCHLV95.Coord2;
----

Wirkt für einen bestimmten generischen Koordinaten-Wertebereich bereits eine Kontextdefinition, kann mit einer neuen Kontextdefinition für denselben generischen Koordinaten-Wertebereich eine neue Festlegung für den konkreten Wertebereich gemacht werden. Diese neuen Wertebereiche müssen aber Spezialisierungen der bestehenden Festlegungen sein.

----
DOMAIN
  Coord2Special EXTENDS GeometryCHLV03.Coord2 = COORD … ;

CONTEXT default =
  MyModel.Coord2 = Coord2Special;
----

==== Wertebereiche von Objektidentifikationen
Identifizierbare Objekte werden immer mit einer Objektidentifikation versehen. Damit für die Systeme klar ist, welcher Speicherplatz dafür vorgesehen werden muss und wie die Objektidentifikationen erzeugt werden müssen, können entsprechende Wertebereiche definiert und diese den Themen bzw. Klassen (vgl. Kapitel 2.5.2 Themen und Kapitel 2.5.3 Klassen und Strukturen) zugeordnet werden. Für die Verwaltung von Objektidentifikationen, insbesondere auch von Behältern, macht es aber Sinn, gewöhnliche Attribute mit solchen Wertebereichen zu führen.

++++
<a href="#2_8_C11">&#x203B</a>
++++
[#2_8_C11]
.Syntaxregel:
----
OIDType = 'OID' ( 'ANY' | NumericType | TextType ).
----

INTERLIS 2 selbst definiert die folgenden OID-Wertebereiche (vgl. Anhang A Das interne INTERLIS-Datenmodell):

----
DOMAIN
  NOOID = OID ANY;                             !! beliebiger, nicht stabiler
                                               !! Identifikator
  ANYOID (ABSTRACT) EXTENDS NOOID = OID ANY;
  I32OID EXTENDS ANYOID = OID 0 .. 2147483647; !! positive, 4 Bytes Integerwerte
  STANDARDOID EXTENDS ANYOID = OID TEXT*16;    !! gemäss Anhang F (nur Ziffern
                                               !! und Buchstaben erlaubt)
  UUIDOID EXTENDS ANYOID = OID TEXT*36;        !! gemäss ISO 11578
----

Es ist nicht möglich, eine OID-Definition zu erweitern, ausser dass ein `NOOID` durch `ANYOID`, und `ANYOID` zu einer konkreten Definition (nicht `OID ANY`) erweitert werden kann.

Wird `ANYOID` für abstrakte Themen bzw. Klassen angewendet, wird verlangt, dass eine Objektidentifikation erwartet wird, die genaue Definition aber noch offen ist. Sonst kann `ANYOID` nur als Wertebereich von Attributen verwendet werden. Zum Attributwert gehört dann nicht nur die eigentliche `OID`, sondern auch der konkrete OID-Wertebereich. OID-Werte von textlichen OID-Wertebereichen müssen die XML-ID Regel in Kapitel 3.3.1 erfüllen: erstes Zeichen muss ein Buchstabe, eine Ziffer oder ein Unterstrich sein, dann folgen Buchstaben, Ziffern, Punkte, Minuszeichen, Unterstriche; keine Doppelpunkte (!).

==== Gefässe
Durch Einsatz dieses Datentyps können Attribute modelliert werden, deren Inhalt nicht spezifiziert werden kann. Die Variante `XML` beschreibt ein Attribut mit XML-Inhalt und die Variante `BINARY` einen binären Inhalt. Dieser Typ kann in Erweiterungen nicht verfeinert werden.

++++
<a href="#2_8_C12">&#x203B</a>
++++
[#2_8_C12]
.Syntaxregel:
----
BlackboxType = 'BLACKBOX' ( 'XML' | 'BINARY' ).
----

==== Wertebereiche von Klassen und Attributpfaden
Es kann Sinn machen, dass Datenobjekte Verweise auf bestimmte Klassen und Attribute enthalten.

++++
<a href="#2_8_C13">&#x203B</a>
++++
[#2_8_C13]
.Syntaxregeln:
----
ClassType = ( 'CLASS'
                [ 'RESTRICTION' '(' ViewableRef
                                    { ';' ViewableRef } ')' ]
            | 'STRUCTURE'
                [ 'RESTRICTION' '(' ClassOrStructureRef
                                    { ';' ClassOrStructureRef } ')' ] ).

AttributePathType = 'ATTRIBUTE'
                    [ 'OF' ( ClassType-AttributePath
                           | '@' Argument-Name ) ]
                    [ 'RESTRICTION' '(' AttrTypeDef
                                        { ';' AttrTypeDef } ')' ].

ClassConst = '>' ViewableRef.

AttributePathConst = '>>' [ ViewableRef '->' ] Attribute-Name.
----

Mit der Angabe von `STRUCTURE` wird eine beliebige Struktur oder Klasse, mit `CLASS` (auch als Erweiterung von `STRUCTURE` zulässig) eine beliebige Klasse (aber keine Strukturen) zugelassen. Sollen nur bestimmte Strukturen bzw. Klassen und ihre Erweiterungen zugelassen sein, sind diese aufzuführen (`RESTRICTION`). In Erweiterungen müssen erneut alle zulässigen Strukturen bzw. Klassen aufgeführt werden. Sie dürfen aber nicht im Widerspruch zur Basisdefinition sein. Sobald solche Einschränkungen definiert sind, kann darum `STRUCTURE` nicht mehr durch `CLASS` erweitert werden.

Mit der Angabe von `ATTRIBUTE` wird ein Attributpfadtyp zugelassen. Es kann verlangt werden, dass es zu einer Klasse (keine Subklasse!) gemäss einer anderen Definition gehört (`OF`). Dabei kann entweder auf ein ClassType-Attribut oder im Falle einer Definition einer Funktion (vgl. Kapitel 2.14 Funktionen) auf ein anderes Argument verwiesen werden. Die möglichen Attributtypen können zudem eingeschränkt werden (`RESTRICTION`). Als Konstante kommen die Namen von Attributen der Klassen, Strukturen, Assoziationen und Sichten in Frage. Der entsprechende Klassenname kann explizit angegeben werden oder ergibt sich aus dem Kontext bzw. aus dem Verweis auf ein anderes Attribut oder ein anderes Argument (`OF`).

==== Linienzüge
===== Geometrie des Linienzugs
Anschaulich ist ein Kurvenstück ein 1-dimensionales Gebilde, das keine Risse, keine Ecken und keine Doppelpunkte jeglicher Art hat (siehe Figuren 10 und 11). Kurvenstücke sind also glatt und eindeutig. Strecken, Kreisbogen, Parabel- und Klothoidenstücke sind Beispiele von Kurvenstücken. Jedes Kurvenstück hat zwei _Randpunkte_ (Anfangs- und Endpunkt), die nicht zusammenfallen dürfen. Die übrigen Punkte des Kurvenstückes heissen _innere Punkte_. Diese bilden das _Innere_ des Kurvenstückes.

[sidebar]
--
Exakte Definition (mathematische Begriffe, die nicht weiter erklärt werden, deren Definition man aber in Lehrbüchern findet, werden "_kursiv und in Anführungszeichen_" geschrieben): _Kurvenstück_ heisst eine Teilmenge des "_3-dimensionalen_" "_Euklidischen Raumes_" (im folgenden kurz _Raum_ genannt), die "_Bildmenge_" einer "_glatten_" und "_injektiven_" "_Abbildung_" eines "_Intervalls_" (der "_Zahlengerade_") ist. Anfangs- und Endpunkt des Kurvenstücks sind die Bilder der Intervallenden. _Ebenes Kurvenstück_ heisst ein Kurvenstück, das in einer Ebene ("_2-dimensionaler_" "_Unterraum_" des Raumes) liegt.
--

.Beispiele von ebenen Kurvenstücken.
image::{includedir}/img/refhb24_fig10.png[]

.Beispiele von ebenen Mengen, die nicht Kurvenstücke sind (ein doppelter Kreis bedeutet "nicht glatt" und ein doppeltes Rechteck "nicht injektiv").
image::{includedir}/img/refhb24_fig11.png[]

Ein Linienzug ist eine endliche Folge von Kurvenstücken. Ausser beim ersten Kurvenstück stimmt der Anfangspunkt jeweils mit dem Endpunkt des Vorgänger-Kurvenstückes überein. Diese Punkte heissen Stützpunkte des Linienzuges. Anschaulich kann ein Linienzug mehrfach benützte Kurvenstücke, Kurvenstücke mit zusammenfallenden Stützpunkten, sich schneidende Kurvenstücke und im Innern von Kurvenstücken endende oder startende Kurvenstücke enthalten (siehe Figuren 12 und 13). Ein einfacher Linienzug weist keinerlei Selbst-Schnittpunkte auf (siehe Figur 14). Bei einem einfach geschlossenen Linienzug stimmt zudem der Anfangspunkt des ersten Kurvenstücks mit dem Endpunkt des letzten überein.

[sidebar]
--
Exakte Definition (mathematische Begriffe, die nicht weiter erklärt werden, deren Definition man aber in Lehrbüchern findet, werden "_kursiv und in Anführungszeichen_" geschrieben): _Linienzug_ heisst eine Teilmenge des Raumes, die "_Bildmenge_" einer "stetigen" und "_stückweise glatten_" (aber nicht notwendigerweise "_injektiven_") "_Abbildung_" eines "_Intervalls_" ist (der so genannten _zugeordneten Abbildung_) und nur endlich viele "_nicht glatte Stellen_" aufweist. Eine "_nicht glatte Stelle_" heisst Ecke. Bei einem _geschlossenen Linienzug_ stimmen Anfangs- und Endpunkt überein. _Einfacher Linienzug_ heisst ein Linienzug, dessen zugeordnete Abbildung auch "_injektiv_" ist. _Einfach geschlossener Linienzug_ heisst ein Linienzug, dessen zugeordnete Abbildung auch "_injektiv_" ist, abgesehen von seinem Anfangs- und Endpunkt, die übereinstimmen.
--

.Beispiele von (ebenen) Linienzügen.
image::{includedir}/img/refhb24_fig12.png[]

.Beispiele von ebenen Mengen, die nicht Linienzüge sind (ein doppelter Kreis bedeutet hier "nicht stetig" und der Rhombus "nicht Bild eines Intervalls").
image::{includedir}/img/refhb24_fig13.png[]

.Beispiele von (ebenen) einfachen Linienzügen.
image::{includedir}/img/refhb24_fig14.png[]

===== Linienzug mit Strecken und Kreisbogen als vordefinierte Kurvenstücke
INTERLIS 2 kennt gerichtete (`DIRECTED POLYLINE`), ungerichtete (`POLYLINE`) oder eine Menge von ungerichteten (`MULTIPOLYLINE`) Linienzügen. Bei einem einzelnen Linienzug (`[DIRECTED] POLYLINE`) sind aber beim Transfer eines Ausschnittes auch `MULTIPOLYLINE` zulässig (vgl. Kapitel 3.3.6 Codierung von Themen). Bei einer Menge von Linienzügen (`MULTIPOLYLINE`) müssen die einzelnen Linienzüge nicht miteinander verbunden sein. Zudem werden Linienzüge im Rahmen von Einzelflächen und Gebietseinteilungen (vgl. Kapitel 2.8.13 Einzelflächen und Gebietseinteilungen) verwendet.

Zur Definition eines konkreten Linienzug-Wertebereichs gehört immer die Angabe der erlaubten Kurvenstück-Formen mittels Aufzählung, z.B. Strecken (Schlüsselwort `STRAIGHTS`), Kreisbogen (Schlüsselwort `ARCS`) oder weitere Möglichkeiten (vgl. Kapitel 2.8.12.3 Weitere Kurvenstück-Formen), und die Angabe des Wertebereichs der Stützpunkte. In einem abstrakten Linienzug-Wertebereich dürfen diese Angaben fehlen. Für Wertebereichserweiterungen gelten folgende Regeln:

* Die Kurvenstück-Form darf nur reduziert, nicht aber ergänzt werden.

* Der Koordinaten-Wertebereich, der im Rahmen einer Erweiterung eines Linienzug-Wertebereichs angegeben wird, muss eine Einschränkung des Koordinaten-Wertebereichs des Basis-Linienzug-Wertebereichs sein, sofern ein solcher definiert ist.

Die Kurvenstücke werden immer als Erweiterung der Grundstruktur 'LineSegment' aufgefasst. Der darin verwendete Koordinatenwertebereich ist der in der Liniendefinition angegebene.

----
STRUCTURE LineSegment (ABSTRACT) =
  SegmentEndPoint: MANDATORY LineCoord;
END LineSegment;

STRUCTURE StartSegment (FINAL) EXTENDS LineSegment =
END StartSegment;

STRUCTURE StraightSegment (FINAL) EXTENDS LineSegment =
END StraightSegment;

STRUCTURE ArcSegment (FINAL) EXTENDS LineSegment =
  ArcPoint: MANDATORY LineCoord;
  Radius: NUMERIC [LENGTH];
END ArcSegment;
----

Das erste Kurvenstück eines Linienzuges ist immer ein Startsegment. Das Startsegment besteht nur aus dem Startpunkt selbst, der zugleich auch Endpunkt des Startsegments ist. Das Geradenstück hat einen Endpunkt und definiert dadurch eine Strecke vom Endpunkt des vorherigen Kurvenstücks zu seinem Endpunkt. Startsegment und Geradenstücke brauchen keine weiteren Angaben. Die entsprechenden Erweiterungen von 'LineSegment' sind darum leer. Zwei aufeinander folgende Stützpunkte (SegmentEndPoints) dürfen in der Projektion nicht aufeinander fallen.

Ein Kreisbogenstück beschreibt ein Kurvenstück, das in der Projektion als echtes Kreisbogenstück erscheint. Ein Kreisbogenstück wird zusätzlich zum Endpunkt mit einem Zwischenpunkt beschrieben. Dieser ist nur in der Lage von Bedeutung. Bei dreidimensionalen Koordinaten wird die Höhe auf dem Kreisbogenstück linear interpoliert. Man kann sich die Kurve als Gewindestück einer zylindrischen Schraube vorstellen, die senkrecht auf der Projektionsfläche steht. Der Zwischenpunkt ist kein Stützpunkt des Linienzuges. Er soll möglichst exakt in der Mitte zwischen Anfangs- und Endpunkt liegen. Der Zwischenpunkt wird mindestens in der gleichen Genauigkeit angegeben (Anzahl Nachkommastellen) wie die Stützpunkte. Um numerische Probleme (vgl. unten) zu vermeiden, sollen Stützpunkte möglichst mit zusätzlicher Genauigkeit transferiert werden. Dennoch kann der berechnete Radius erheblich vom effektiven Radius abweichen. Wird der effektive Radius angegeben, ist er für die Kreisbogendefinition massgebend. Der Zwischenpunkt legt nur noch fest, welcher der vier möglichen Kreisbogen der gewünschte ist. Der Zwischenpunkt darf aber auch in diesem Fall um höchstens 1 Genauigkeitseinheit (der Wert 1 der hintersten Stelle gemäss Wertebereichsdefinition; z.B. 0.001 bei Koordinaten mit 3 Nachkommastellen) von der Spur des aus dem Radius gerechneten Kreisbogens abweichen. Aus fachlicher Sicht soll oft ausgedrückt werden, dass es sich bei einem Linienzug um einen einfachen Linienzug handelt, d.h. anschaulich, dass er sich nicht mit sich selbst schneiden darf und insbesondere mehrfache Benützung desselben Kurvenstücks ausgeschlossen ist (Schlüsselwort `WITHOUT OVERLAPS`). Dieses Anliegen wird auch durch verschiedene konkrete Systeme unterstützt. Dabei besteht allerdings das technische Problem, dass in Grenzsituationen (insbesondere im Zusammenhang mit Kreisbogen) unterschiedliche Systeme auf Grund unterschiedlicher Rechengenauigkeiten und unterschiedlicher Berechnungsweisen zu unterschiedlichen Resultaten bezüglich Überschneidung kommen. Es muss also damit gerechnet werden, dass ein System kleine Überlappungen akzeptiert oder umgekehrt Überlappungen reklamiert, obwohl ein anderes System zu anderen Schlüssen kommt. "Klein" heisst dabei, dass die potentielle Überlappung kleiner ist als der Wert 1 der hintersten Stelle gemäss Wertebereichsdefinition multipliziert mit der Hälfte der Quadratwurzel von 2 [z.B. 0.001 * sqrt(2) / 2 bei Koordinaten mit 3 Nachkommastellen].

Aus fachlicher Sicht kann es vor allem bei der Übernahme von Daten, die ursprünglich grafisch erfasst wurden, auch Sinn machen, grössere Überlappungen (z.B. einige Zentimeter) zu tolerieren, um einen enormen Nachbearbeitungsaufwand zu vermeiden.

Um beide Anliegen zu unterstützen, wird die Überlappungsfreiheit wie folgt geregelt:

Wenn ein Kreisbogen und eine Strecke (bzw. ein anderer Kreisbogen) als aufeinander folgende Kurvenstücke eines Linienzuges neben dem gemeinsamen Stützpunkt auch noch einen inneren Punkt (keinen Stützpunkt) gemeinsam haben, so ist das auch bei einem einfachen Linienzug erlaubt, falls das von der Strecke abgeschnittene Kreissegment (bzw. das vom anderen Kreisbogen abgeschnittene Doppel-Kreissegment) eine Pfeilhöhe aufweist, die kleiner oder gleich der definierten Toleranz ist. Fehlt die Toleranzangabe, gilt der Wert gemäss den technischen Überlegungen (vgl. oben). Bei expliziter Angabe (auf WITHOUT OVERLAPS > folgende Dezimalzahl) muss sie mit derselben numerischen Bedeutung wie diejenige der Stützpunktkoordinaten erfolgen und einen Wert grösser Null aufweisen.

.a) Die Pfeilhöhe darf nicht grösser als die angegebene Toleranz sein; b), c) unzulässige Überschneidungen eines Linienzuges, da Strecke und Kreisbogen, die sich treffen, nicht von einem gemeinsamen Stützpunkt ausgehen.
image::{includedir}/img/refhb24_fig15.png[]

Bei Einzelflächen und Gebietseinteilung ist die Überlappungsfreiheit zwingend. Bei Verwendung der impliziten Toleranz kann deshalb auf `WITHOUT OVERLAPS` verzichtet werden.

Die Toleranzangabe (explizit oder implizit) kann nicht übersteuert werden. Im Rahmen von Wertebereichsdefinitionen und Attributserweiterungen können ungerichtete Linienzüge zu gerichteten Linienzügen erweitert werden (vgl. Kapitel 2.8.13.4 Erweiterbarkeit).

Sind Linienzüge gerichtet, muss ihr Richtungssinn immer (auch bei einem Datentransfer) erhalten bleiben.

Für die Stützpunkte wird der Wertebereich der Koordinaten definiert. Mittels der Existenzbedingung `REQUIRED IN` (vgl. Kapitel 2.12 Konsistenzbedingungen und Kapitel 2.13 Ausdrücke) kann zudem gefordert werden, dass die Koordinaten nicht beliebig sein dürfen, sondern denjenigen der Punkte bestimmter Klassen entsprechen müssen.

Ist der Koordinatentyp der Stützpunkte abstrakt, muss der Linienzug seinerseits als abstrakt deklariert werden.

++++
<a href="#2_8_C14">&#x203B</a>
++++
[#2_8_C14]
.Syntaxregeln:
----
LineType = ( [ 'DIRECTED' ] 'POLYLINE' | 'SURFACE' | 'AREA' |
            [ 'DIRECTED' ] 'MULTIPOLYLINE' | 'MULTISURFACE' | 'MULTIAREA' )
           [ LineForm ] [ ControlPoints ] [ IntersectionDef ].

LineForm = 'WITH' '(' LineFormType { ',' LineFormType } ')'.

LineFormType = ( 'STRAIGHTS' | 'ARCS'
               | [ Model-Name '.' ] LineFormType-Name ).

ControlPoints = 'VERTEX' CoordType-DomainRef.

IntersectionDef = 'WITHOUT' 'OVERLAPS' [ '>' Dec ].
----

Linien können auf generischen Koordinaten aufbauen, ohne dass sie selbst als generisch deklariert werden. Sie erhalten ihre konkrete Festlegung mit der Festlegung des Koordinaten-Wertebereichs (im Rahmen einer Kontextdefinition bzw. im Rahmen des Datentransfers). Es ist dafür nicht nötig (aber durchaus zulässig), dass zu Linien-Wertebereichen, die auf generischen Koordinaten-Wertebereichen aufbauen, Linien-Wertebereiche definiert sind, die auf konkreten Koordinaten-Wertebereichen aufbauen.

----
DOMAIN
  Coord2 (GENERIC) = COORD NUMERIC, NUMERIC;
  Line = POLYLINE WITH (STRAIGHTS, ARCS) VERTEX Coord2;
----

===== Weitere Kurvenstück-Formen
Nebst Geradenstücken und Kreisbogen sind weitere Kurvenstück-Formen definierbar. Nebst dem Namen muss angegeben werden, gemäss welcher Struktur ein Kurvenstück beschrieben wird.

++++
<a href="#2_8_C15">&#x203B</a>
++++
[#2_8_C15]
.Syntaxregeln
----
LineFormTypeDef = 'LINE' 'FORM'
                    { LineFormType-Name ':' LineStructure-Name ';' }.
----

Eine Linienstruktur muss immer eine Erweiterung der durch INTERLIS definierten Struktur LineSegment sein (vgl. Kapitel 2.8.12.2 Linienzug mit Strecken und Kreisbogen als vordefinierte Kurvenstücke).

==== Einzelflächen und Gebietseinteilungen
===== Geometrie von Flächen
Für die Modellierung von Geodaten genügen meist ebene Flächen. INTERLIS unterstützt darüber hinaus ebene allgemeine Flächen. Anschaulich ist eine ebene allgemeine Fläche durch eine äussere und allenfalls eine oder mehrere innere Randlinien begrenzt (siehe Figur 20). Die Randlinien selbst müssen aus einfachen Linienzügen bestehen, die aus geometrischer Sicht jeweils zu einfach geschlossenen Linienzügen zusammengefasst werden können. Sie müssen zudem so angeordnet sein, dass es von einem beliebigen Punkt im Innern der Fläche immer einen Weg zu einem beliebigen anderen Punkt im Innern der Fläche gibt, der weder eine Randlinie schneidet noch einen Stützpunkt einer Randlinie enthält (siehe Figur 19). Soweit diese Bedingung nicht verletzt wird, dürfen sich Ränder in Stützpunkten berühren. In solchen Situationen kann man sich verschiedene Möglichkeiten vorstellen, wie die Umrandung der Fläche als Ganzes in einzelne Linienzüge aufgeteilt wird (siehe Figur 22). INTERLIS macht keine Vorschriften, welche Möglichkeit gewählt wird. Wird eine solche Fläche mehrmals transferiert, dürfen in den verschiedenen Übertragungen auch unterschiedliche Aufteilungen vorkommen.

[sidebar]
--
Exakte Definitionen (mathematische Begriffe, die nicht weiter erklärt werden, deren Definition man aber in Lehrbüchern findet, werden "_kursiv und in Anführungszeichen_" geschrieben):

_Flächenelement_ heisst eine Teilmenge des _Raumes_, die "_Bildmenge_" einer "_glatten_" und "_injektiven_" "_Abbildung_" eines "_ebenen_" "_regulären Vielecks_" ist (siehe Figuren 16 und 17).

_Fläche_ heisst die Vereinigung _F_ von endlich vielen Flächenelementen, die "_zusammenhängend_" ist und folgender Bedingung genügt: Zu jedem Punkt _P_ der Fläche gibt es eine "_Umgebung_", die sich in ein ebenes reguläres Vieleck _deformieren_ (d.h. "_homöomorph abbilden_") lässt. Wenn bei einer solchen Deformation der Punkt _P_ in den Rand des Vielecks übergeführt wird, heisst er _Randpunkt_ von _F_, andernfalls _innerer Punkt_ von _F_. Es gilt: Der "_Rand_" (d.h. die Menge aller Randpunkte) einer Fläche ist die Vereinigung von endlich vielen Kurvenstücken, die nur Endpunkte gemeinsam haben. Eine _ebene Fläche_ ist eine Fläche, die Teilmenge einer _Ebene_ ist. Es gilt: Der Rand einer "_einfach zusammenhängenden_" ebenen Fläche (anschaulich: einer Fläche ohne Löcher) ist ein einfach geschlossener Linienzug und heisst _äusserer Rand_. Der Rand einer "_n-fach zusammenhängenden_" ebenen Fläche (anschaulich: einer Fläche mit _n-1_ Löchern) besteht aus dem entsprechenden äusseren Rand und aus _n-1_ weiteren einfach geschlossenen Linienzügen (den so genannten _inneren Rändern_). Der äussere Rand und alle inneren Ränder haben keine Punkte gemeinsam. Ein durch einen inneren Rand ausgespartes Flächenstück heisst _Enklave_ (siehe Figuren 18, 19 und 20).
Eine _allgemeine Fläche_ ist eine Fläche mit zusätzlich endlich vielen _singulären Punkten_ aber mit "_zusammenhängendem_" _Inneren_ (Menge der inneren Punkte). Ein _singulärer Punkt_ kann zusammen mit einer "_Umgebung_" in eine ebene _Propellermenge_ deformiert werden, er selbst ins _Zentrum_. _Propellermenge_ heisst die Vereinigung endlich vieler Dreiecksflächen, die genau einen Punkt gemeinsam haben, das _Zentrum_. _Ebene allgemeine Fläche_ heisst eine allgemeine Fläche, die Teilmenge einer _Ebene_ ist (siehe Figur 21). Es gilt: Der Rand einer ebenen allgemeinen Fläche kann auf verschiedene Art zusammengesetzt werden aus endlich vielen geschlossenen Linienzügen, die höchstens endlich viele Punkte gemeinsam haben und je höchstens endlich viele Doppelpunkte aufweisen (siehe Figur 22).
--

.Beispiele von Flächenelementen.
image::{includedir}/img/refhb24_fig16.png[]

.Beispiele von Punktmengen im Raum, die nicht Flächenelemente sind (ein doppelter Kreis bedeutet hier "nicht glatt").
image::{includedir}/img/refhb24_fig17.png[]

.Beispiele von Flächen im Raum.
image::{includedir}/img/refhb24_fig18.png[]

.Beispiele ebener Punktmengen, die nicht Flächen sind (ein doppelter Kreis bedeutet "singulärer Punkt").
image::{includedir}/img/refhb24_fig19.png[]

.Ebene Fläche mit Rändern und Enklaven.
image::{includedir}/img/refhb24_fig20.png[]

.a) Beispiele von allgemeinen ebenen Flächen; b) Beispiele von ebenen Mengen, die nicht allgemeine Flächen sind, weil ihr Inneres nicht zusammenhängend ist. Diese ebenen Mengen können aber in allgemeine Flächen unterteilt werden ("---" zeigt die Unterteilung in Flächenelemente und "===" die Unterteilung in allgemeine Flächen).
image::{includedir}/img/refhb24_fig21.png[]

.Verschiedene mögliche Aufteilungen des Randes einer allgemeinen Fläche.
image::{includedir}/img/refhb24_fig22.png[]

Mit der Definition von (allgemeinen) Einzelflächen bzw. (allgemeinen) Flächen einer Gebietseinteilung wird auch festgelegt, oberhalb welcher Toleranz sich die Kurvenstücke des Randes nicht überlappen dürfen (ohne Angabe von `WITHOUT OVERLAPS` gilt die implizite bzw. die geerbte Toleranz). Das Überlappungs- bzw. Schnittverbot gilt bei Einzelflächen nicht nur zwischen den Kurvenstücken eines einzelnen Linienzuges sondern zwischen allen Kurvenstücken aller Linienzüge des Flächenrandes. Für Flächen einer Gebietseinteilung gilt es sogar für alle an der Gebietseinteilung beteiligten Linienzüge. Zudem sind Linienzüge, die nicht zum Rand einer (allgemeinen) Fläche gehören, gemäss Definition der (allgemeinen) Fläche ausgeschlossen.

.Nicht erlaubte Linien von Flächen.
image::{includedir}/img/refhb24_fig23.png[]

===== Einzelflächen
.Einzelflächen (`SURFACE`).
image::{includedir}/img/refhb24_fig24.png[]

Für (allgemeine) Flächen, die sich ganz oder teilweise überlappen dürfen, d.h. die nicht nur Randpunkte gemeinsam haben dürfen, steht der geometrische Attributtyp `SURFACE` zur Verfügung (siehe Figur 24). Dieser Typ wird Einzelflächen genannt. Eine Einzelfläche hat einen äusseren und allenfalls mehrere inneren Ränder (um die Enklaven). Jeder Rand besteht aus mindestens einem Linienzug.

Mit dem Attributtyp `MULTISURFACE` kann auch eine Menge von Einzelflächen als ein einzelner Wert definiert werden. Die einzelnen Flächen eines MULTISURFACE-Wertes dürfen keine gemeinsamen Kanten haben und dürfen sich abgesehen von Overlaps nicht überlappen.

===== Flächen einer Gebietseinteilung
.Gebietseinteilung (`AREA`).
image::{includedir}/img/refhb24_fig25.png[]

_Gebietseinteilung (Flächennetz)_ heisst eine endliche Menge von (allgemeinen) Flächen und Restflächen, welche die Ebene überlappungsfrei überdecken.

Für Gebietseinteilungen steht der geometrische Attributtyp `AREA` zur Verfügung.

Jedem Gebietsobjekt ist höchstens eine Fläche der Gebietseinteilung (oder genau eine mit Zusatz-Schlüsselwort `MANDATORY`), nicht aber die Restfläche, zugeordnet. Es ist nicht zulässig, dass zwei Flächen der Gebietseinteilung mit einem gemeinsamen Rand je keinem Gebietsobjekt entsprechen.

Jedes einzelne Gebietsobjekt entspricht damit einer Einzelfläche. Für Gebietsobjekte ergibt sich damit auch die gleiche implizite Struktur wie für Einzelflächen. Zusätzlich gelten aber Konsistenzbedingungen:

* Linienzüge einer Gebietseinteilung müssen immer echte Grenzlinien sein. Es dürfen also keine Linienzüge existieren, bei denen auf beiden Seiten die gleiche Fläche liegt (siehe Figur 23). Dies ist auch durch die Definition der Fläche ausgeschlossen.

* Liegen auf beiden Seiten eines Linienzuges definierte Gebietsobjekte, muss jedes Kurvenstück (Verbindung zweier Stützpunkte) des einen Gebietsobjektes in Geometrie und Attributen genau einem Kurvenstück des anderen Gebietsobjektes entsprechen.

Gebietseinteilungen dürfen nicht innerhalb von Unterstrukturen vorkommen.

Damit die Linienzüge einer Gebietseinteilung auch als einzelne Objekte angesprochen werden können (und zwar als ein Objekt, auch wenn der Linienzug zwei Gebietsobjekte begrenzt), steht die `AREA INSPECTION` zur Verfügung (vgl. Kapitel 2.15 Sichten).

===== Erweiterbarkeit
Einzelflächen können zu Gebietseinteilungen erweitert werden. Die Erweiterung eines Linienzuges zu einer Fläche ist unzulässig, da bei einer Fläche mit mehreren Linienzügen gerechnet werden muss, während mit der Definition eines Linienzuges nur einer erwartet wird.

Unabhängige Flächen und Flächen einer Gebietseinteilung können in zweierlei Hinsicht erweitert werden:

* Ist primär `SURFACE` definiert, sind also Überlappungen zugelassen, darf dies in Erweiterungen durch `AREA` ersetzt werden, da damit die Grunddefinition nicht verletzt wird.
